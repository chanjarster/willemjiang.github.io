<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>blog of Willem Jiang</title>
    <description>blog of Willem Jiang</description>
    <link>http://willemjiang.github.io/</link>
    <atom:link href="http://willemjiang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 16 Jul 2018 09:50:50 +0800</pubDate>
    <lastBuildDate>Mon, 16 Jul 2018 09:50:50 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>Apache Camel 2.22.0发布了</title>
        <description>&lt;h2&gt;概述&lt;/h2&gt;

&lt;p&gt;Apache Camel 大约每个季度会发布一个新版本，Camel  2.22.0 如约在7月3号正式发布了。 这次版本发布最值得关注的更新是， Apache Camel 2.22.0 开始正式支持Spring Boot 2.x，当然考虑到维护问题 Apache Camel 2.22.0 不再支持Spring Boot 1.x， 这里建议Apache Camel的使用者尽快升级到Spring Boot 2.x。 如果现在还不想升级Spring Boot 1.x, 那就只能使用Camel 2.21.x （按照常规，Camel 2.21.x 在社区还会有半年左右的支持维护期）。值得一提的是&lt;a href=&quot;https://start.spring.io/&quot;&gt;Spring Boot Start&lt;/a&gt;已经支持Apache Camel， 如果使用Spring Boot 2.x会自动适配Camel 2.22.x版本。&lt;/p&gt;

&lt;p&gt;Apache Camel 正式支持 Spring 5，由于Camel没有使用Spring5的独有特性，因此Apache Camel 2.22.0 依旧可以同Spring 4.x 一起使用，不过在后续的版本中会考虑修改Camel支持Spring的最低版本。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/toD-eip.adoc&quot;&gt;ToD  EIP&lt;/a&gt; 允许用户通过&lt;a href=&quot;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/expression.html&quot;&gt;表达式&lt;/a&gt;的方式来动态定义消息的接收节点，由于节点信息是动态创建了， 在Camel 2.22.0 中针对这部分进行了优化，如果消息接收节点是HTTP 节点的话， Camel会自动复用同一主机端口的连接，减少消息路由的系统负担。 &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://camel.apache.org/rest-dsl.html&quot;&gt;Rest DSL&lt;/a&gt;也在Camel 2.22.0里面进行优化。 首先是支持&lt;a href=&quot;http://camel.apache.org/rest-dsl.html&quot;&gt;Rest DSL&lt;/a&gt;支持对客户端的请求的Content-Type信息以及返回消息的Response-Type信息进行验证，其次是扩展了针对Swagger安全信息定义的支持，最后是 &lt;a href=&quot;http://camel.apache.org/rest-dsl.html&quot;&gt;Rest DSL&lt;/a&gt;的Producer端也支持通过endpointProperties的方式来进行配置了。 &lt;/p&gt;

&lt;p&gt;针对云化应用场景，Camel 2.22.0 也提供了一个新的&lt;a href=&quot;https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/cloud/ServiceRegistry.java&quot;&gt;Service Registry&lt;/a&gt;的服务节点接口，支持将Camel的路由信息注册 Consul, etcd, Zookeeper常规的服务注册中心上的功能。 这样大家可以很方便地将定义好的Camel 路由以云化多实例应用的方式对外发布。&lt;/p&gt;

&lt;h2&gt;新增组件&lt;/h2&gt;

&lt;p&gt;在Apache Camel 2.22.0 中还新增加了如下的组件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-as2/camel-as2-component/src/main/docs/as2-component.adoc&quot;&gt;camel-as2&lt;/a&gt; - 支持使用&lt;a href=&quot;https://tools.ietf.org/html/rfc4130&quot;&gt;AS2(Applicability Statement 2)协议&lt;/a&gt;进行传输。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-google-mail/src/main/docs/google-mail-stream-component.adoc&quot;&gt;camel-google-mail-stream&lt;/a&gt; - 提供了采用流式方式访问 Google 邮箱。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-micrometer/src/main/docs/micrometer-component.adoc&quot;&gt;camel-micrometer&lt;/a&gt; - 使用&lt;a href=&quot;http://micrometer.io/&quot;&gt;Micrometer&lt;/a&gt;来收集Camel内部的相关统计信息。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-mybatis/src/main/docs/mybatis-bean-component.adoc&quot;&gt;camel-mybatis-bean&lt;/a&gt; - 支持使用&lt;a href=&quot;http://mybatis.org/&quot;&gt;MyBatis&lt;/a&gt; bean 标注的方式来对关系型数据库进行增删改查。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-service/src/main/docs/service-component.adoc&quot;&gt;camel-service&lt;/a&gt; - 通过向服务注册中心获取访问示例来实现对多个服务实例的访问。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-web3j/src/main/docs/web3j-component.adoc&quot;&gt;camel-web3j&lt;/a&gt; - 使用 &lt;a href=&quot;https://github.com/web3j/web3j&quot;&gt;web3j&lt;/a&gt; 客户端与&lt;a href=&quot;https://www.ethereum.org/&quot;&gt;Ethereum&lt;/a&gt;的相兼容的节点进行交互。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-rxjava2/src/main/docs/rxjava2-component.adoc&quot;&gt;camel-rxjava2&lt;/a&gt; - 使用&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava2&lt;/a&gt; 来实现Camel的响应式流组件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-testcontainers/src/main/docs/testcontainers.adoc&quot;&gt;camel-testcontainers&lt;/a&gt; - 支持使用&lt;a href=&quot;https://www.testcontainers.org&quot;&gt;testcontainers&lt;/a&gt; 来通过扩展&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-testcontainers/src/main/java/org/apache/camel/test/testcontainers/ContainerAwareTestSupport.java&quot;&gt;ContainerAwareTestSupport&lt;/a&gt; 采用docker方式启动相关的服务。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://camel.apache.org/camel-2220-release.html&quot;&gt;Apache Camel 2.22.0 Download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ReleaseNote.jspa?version=12342707&amp;amp;projectId=12311211&quot;&gt;Apache Camel 2.22.0 Release Note&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.davsclaus.com/2018/07/apache-camel-222-released-with-spring.html&quot;&gt;Claus Blog: Apache Camel 2.22 Released with Spring Boot 2 support&lt;/a&gt; &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 16 Jul 2018 01:34:04 +0800</pubDate>
        <link>http://willemjiang.github.io/camel-2220-was-released</link>
        <guid isPermaLink="true">http://willemjiang.github.io/camel-2220-was-released</guid>
        
        <category>Camel</category>
        
        
        <category>Camel</category>
        
      </item>
    
      <item>
        <title>开源社区的交流准则</title>
        <description>&lt;p&gt;前段时间和大家聊了&lt;a href=&quot;https://willemjiang.github.io/blog/2016/why-we-use-mailing-list/&quot;&gt;为什么开源社区会选择邮件列表作为讨论交流的平台&lt;/a&gt;， 今天在Apache官方Twitter上面看到了这样一组有意思的数据：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At Apache, &amp;quot;if it didn&amp;#39;t happen on-list, it didn&amp;#39;t happen.&amp;quot; Over the past 2 wks 7,602 people sent 77,412 emails on 35,848 topics &amp;amp; 643 lists.&lt;/p&gt;

&lt;p&gt;在Apache，”只有在邮件列表上面发生的事情才真正发生“。 在最近两周，有7602人在643个邮件列表里面，针对35848个主题发送了77412封邮件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;平均下来一个人在两个礼拜的时间内会发十封信，这样流量还是挺不少的。&lt;/p&gt;

&lt;p&gt;在国内大部分开源社区的交流可能会发生在微信或者QQ群，或者是其他的论坛。为了积攒人气，有些人可能喜欢刷屏，或者灌水。但这样灌水的情况在邮件列表里面却很少发生，难道大家不喜欢凑热闹吗?&lt;/p&gt;

&lt;p&gt;开源社区的交流是建立在志愿服务的基础上的，参与讨论的人没有任何义务要回复你的问题，大家投入时间参与讨论，是建立在一个共赢的基础上的。只要讨论的问题是大家关心的问题，大家觉得这样的讨论是有价值的，自然就会有人参与进来。试想一下，如果你通过灌水，刷屏来寻找存在感，这样的行为会让人觉得你是在浪费大家的时间，你不尊重这个讨论问题的环境。&lt;/p&gt;

&lt;p&gt;在开源社区中，你的名声不是靠你职位来获得，而是靠你在社区里面积累的影响力。影响力的大小和你在社区中贡献大小有很直接的关系。如果你长期在邮件列表里面高质量地回复问题，那你在邮件列表里说话的分量就很重，你在社区的影响力就很大。正是这个原则让我们在寻找社区帮助的时候看到了很多热心的帮助者，他们不计回报地帮助你解决棘手的问题，帮助你成长。对于这样的帮助我们应该心存感激，而不是想当然的认为他们必须要帮助我。&lt;/p&gt;

&lt;p&gt;开源社区的交流是公开的，存档的。任何人可以通过搜索引擎或者其他检索工具检索到绝大部分的交流内容来。这就意味这我们发的邮件或者是提交的评论会被很多人看到（可能是成百上千），而且我们写的内容会在很长时间内帮助其他人很快速了解事情的来龙去脉。为了提高交流的效率，在我们要问问题之前，检索一下是否有类似的讨论，同时言简意赅地表述与主题相关的内容。为了能让我们的问题讨论能让更多的人受益，我们应该选择用公开的通道讨论问题，而不是单独私信他人。&lt;/p&gt;

&lt;p&gt;接下来和大家聊一下为什么在开源社区我们要站在中立的角度上去讨论问题。&lt;/p&gt;

&lt;p&gt;开源社区的交流就好像是我们在一个大厅里说话一样，我们所有交谈的内容大家都能听见，而且有可能会被大家反复播放。如果这个时候我们在吵架，很有可能吸引很多的围观者。在吵架的过程中，我们可能会说出一些让我们后悔说出的话。在平日里这些话可能不会那么刺耳，因为大家可能会很快忘却。但是如果在开源社区，这样伤人的话会作为永久的记录保存下来，而且会被大家随时检索出来。为了让我们的描述足够客观，避免被别人错误理解， 我们也需要注意表达的语气。如果我们在写信的时候，情绪比较激动话，可以选择把过半天或者一天之后在自己情绪不那么激动的时候写信。如果我们在邮件列表里面看到相关的攻击，不要选择加入类似的攻击，而是站在一个比较客观的中立角度来阐述问题。&lt;/p&gt;

&lt;p&gt;在Apache软件基金官网有很多有关社区的行为准则以及交流技巧的文章，大家可以参考下面的链接或者更详细的信息。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.apache.org/foundation/policies/conduct.html&quot;&gt;Apache社区行为准则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://community.apache.org/contributors/etiquette&quot;&gt;Apache社区礼仪指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://apache.org/dev/contrib-email-tips.html&quot;&gt;Apache邮件列表礼仪贴士&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Dec 2016 00:52:36 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2016/opensource-code-of-conduct/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2016/opensource-code-of-conduct/</guid>
        
        <category>Open</category>
        
        <category>Source</category>
        
        
        <category>Open</category>
        
        <category>Source</category>
        
      </item>
    
      <item>
        <title>如何排查Netty内存泄露问题？</title>
        <description>&lt;p&gt;最近我帮着处理了&lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-10409&quot;&gt;一个有关Camel Netty4内存泄露的问题&lt;/a&gt;，起初只是帮着Review相关的&lt;a href=&quot;https://github.com/apache/camel/pull/1268&quot;&gt;PR&lt;/a&gt;，随着工作内容的深入发现了一个暗藏有两年多的内存泄露的&lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-10480&quot;&gt;Bug&lt;/a&gt;。整个除虫的过程很有意思，其中涉及到了在代码里面捕捉Log事件，利用Netty的内存检测工具寻找内存使用的问题等等。&lt;/p&gt;

&lt;h4&gt;预备知识&lt;/h4&gt;

&lt;p&gt;Netty的ByteBuf是一个在Netty编程中经常被使用到的对象，Netty4开始对通过&lt;a href=&quot;http://netty.io/wiki/reference-counted-objects.html&quot;&gt;引用计数&lt;/a&gt;的方式对这样的对象进行管理。如果这类对象的引用计数为0的话，也就是说这些对象已经不再被使用的话，Netty就可将这类对象放回到相关的资源池。&lt;/p&gt;

&lt;p&gt;这样的功能听起来好像和GC的功能很类似，为什么我们不能依赖GC实现这样的功能呢？ 原因是GC的实时性没有这么强，而且从程序代码内部很难直接获取到对象的引用情况。&lt;/p&gt;

&lt;p&gt;下面我们简单看看ByteBuf的引用计数是如何工作的：&lt;/p&gt;

&lt;p&gt;初始化时，引用计数为1：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;ByteBuf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;directBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;refCnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当调用释放操作时，相关的引用计数会-1， 如果引用计数为0， 释放操作会释放内存，或者是把对象放到对象池中：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;refCnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 如果引用计数为0， release() 调用返回 true .&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destroyed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destroyed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;refCnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想延长引用对象的生命周期，可以通过retain方法将引用计数+1&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;ByteBuf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;directBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;refCnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;retain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;refCnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destroyed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destroyed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;refCnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于一个引用计数为0 的对象进行操作的时候，会抛出引用计数的异常&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;refCnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;writeLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xdeadbeef&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;should not reach here&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IllegalReferenceCountExeception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Expected&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Netty内部的Handler在处理ByteBuf的过程中已经使用 try … finally 进行释放了，如果你对Handler进行扩展的话，一般的用户处理逻辑是不会看到相关的内存对象的释放方法的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;channelRead&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChannelHandlerContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ByteBuf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ByteBuf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们需要显式地管理引用计数（GC并不知道Netty的引用计数的实现内容），如果代码逻辑在处理的过程中出现问题（忘记释放内存了，或者是对释放后的内存对象进行操作），就很容易出现内存泄露或者是引用计数的错误。&lt;/p&gt;

&lt;h4&gt;内存泄露检测工具&lt;/h4&gt;

&lt;p&gt;为了方便我们检测内存泄露的问题，Netty提供了一个缺省的内存检测的实现&lt;a href=&quot;https://netty.io/4.0/api/io/netty/util/ResourceLeakDetector.html&quot;&gt;ResourceLeakDetector&lt;/a&gt; 。&lt;a href=&quot;https://netty.io/4.0/api/io/netty/util/ResourceLeakDetector.html&quot;&gt;ResourceLeakDetector&lt;/a&gt;会跟踪引用计数对象的使用情况，并将相关的引用计数对象的使用栈存储下来供开发人员除虫之用。由于引用对象追踪会耗费多的资源，因此对系统会有比较大的影响。运行Netty应用的时候，Netty缺省会采用Simple模式，即采用1%抽样来追踪相关资源分配。如果出现内存泄露，会输入相关log信息，并显示最近相关内存使用情况。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;ERROR io.netty.util.ResourceLeakDetector - LEAK:
 ByteBuf.release() was not called before it's garbage-collected.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于常规的Netty应用来说，如果出现了上面的错误日志，Netty会建议打开ADVANCED监测模式，去获取更多和内存泄露相关的信息。 一般来说这样的操作会给系统带来比较大的负担，&lt;a href=&quot;http://logz.io/blog/netty-bytebuf-memory-leak/&quot;&gt;有人做过统计ADVANCED模式与SIMPLE方式相比，会把系统变慢10倍。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作为开发人员，我们经常会在单元测试里面把泄露级别设置成为PARANOID，就是让资源泄露检测工具对每个Buffer都进行追踪。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;io.netty.leakDetection.maxRecords&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;io.netty.leakDetection.acquireAndReleaseOnly&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ResourceLeakDetector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setLevel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResourceLeakDetector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PARANOID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;camel-netty4的内存泄露问题&lt;/h4&gt;

&lt;p&gt;了解了上面的有关Netty ByteBuff的问题之后，要了解camel-netty4的内存泄露问题就比较简单了。&lt;/p&gt;

&lt;p&gt;对于camel-netty4 组件来说，最近就有用户报了内存泄露的问题， Claus前些时候提供了相关的&lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-9040&quot;&gt;修复&lt;/a&gt;，主要修复的内容就是在CamelExchange执行完毕的时候，如果相关的内存对象引用计数&amp;gt;0,就调用相关方法释放内存。 这样的解决似乎有点太粗暴了，有时候会造成内存的多次释放的问题。 于是Vitalii提出了新的&lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-10409&quot;&gt;解决方案&lt;/a&gt;，其核心内容就是就是把Netty引用计数释放的问题交给Netty自己来做。&lt;/p&gt;

&lt;p&gt;由于Netty的内存检测模块是通过Log的方式输出内存检测信息的，对于我们的单元测试来说不太方便，于是 Vitalii&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-netty4/src/test/resources/log4j2.properties#L28-L32&quot;&gt;配置&lt;/a&gt;了一个log4j2的&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-netty4/src/test/java/org/apache/camel/component/netty4/LogCaptureAppender.java&quot;&gt;LogCaptureAppender&lt;/a&gt;，采用直接截取Log事件的方式在&lt;a href=&quot;https://github.com/apache/camel/blob/master/components/camel-netty4/src/test/java/org/apache/camel/component/netty4/BaseNettyTest.java#L77-L100&quot;&gt;单元测试完毕&lt;/a&gt;的时候检测是否存在内存泄露的问题。 这样就给写我们的单元测试检测Netty内存溢出提供了极大的便利。&lt;/p&gt;

&lt;p&gt;借助这样的Netty提供的内存检测工具以及camel-netty4的单元测试工具，我能在比较快的时间内定位到相关的&lt;a href=&quot;https://github.com/apache/camel/commit/e56cc97612a07cedd5c67ff3c3b1e22bee525dfb&quot;&gt;内存泄露问题&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Nov 2016 02:21:34 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2016/netty-resource-leak-detector/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2016/netty-resource-leak-detector/</guid>
        
        <category>Java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Java二进制兼容问题</title>
        <description>&lt;h4&gt;二进制兼容问题的由来&lt;/h4&gt;

&lt;p&gt;代码库在演进的过程中，或多或少都存在方法，成员变量，以及包的修改。这些修改或多或少会对类库的调用代码产生一些影响。由于Java代码是在运行时进行链接的，编译时的Class Path 和运行时的Class Path是可以完全不一样的。&lt;/p&gt;

&lt;p&gt;如果链接的代码与编译时的代码不是一个版本，且两个版本存在二进制兼容问题，那客户端代码在运行的过程中就会抛出 java.lang.&lt;strong&gt;IncompatibleClassChangeError&lt;/strong&gt;，或者如下的错误&lt;em&gt;NoSuchFieldError&lt;/em&gt;, &lt;em&gt;NoSuchMethodError&lt;/em&gt;, &lt;em&gt;IllegalAccessError&lt;/em&gt;, &lt;em&gt;InstantiationError&lt;/em&gt;, &lt;em&gt;VerifyError&lt;/em&gt;, 
&lt;em&gt;NoClassDefFoundError&lt;/em&gt; and &lt;em&gt;AbstractMethodError&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;这里提到的二进制兼容问题是指客户代码在运行时链接过程中，出现了与编译时不一致的情况。由于&lt;a href=&quot;https://willemjiang.github.io/blog/2006/java-link-post/&quot;&gt;Java的编译链接是分离的&lt;/a&gt;，这样编译时的Class Path 与运行时链接的Class Path是可以完全不一样的，如果客户代码使用的库版本差异很大的话，这样二进制兼容的问题是很容易出现的。&lt;/p&gt;

&lt;p&gt;当出现了二进制兼容问题是，由于我们很少有机会修改库代码，解决的办法往往是重新编译调用相关类库的客户代码或者降级相应的类库的版本。&lt;/p&gt;

&lt;p&gt;在笔者开发Apache Camel过程中遇到Spring 3.x ， Spring 4.x Test库的二进制兼容问题。由于Spring 4.x删除了一个Static方法的定义，我们没有办法在同时支持Spring 3.x 和 Spring 4.x, 只能选择缺省支持Spring3.x， 对于高版本单独发布Spring 4.x的编译版本。&lt;/p&gt;

&lt;p&gt;二进制兼容的问题会给用户的使用带来很大的不方便，作为类库的开发人员，我们需要在API的演进过程中尽量避免出现二进制兼容的问题。 &lt;/p&gt;

&lt;h4&gt;那些修改是会导致二进制兼容问题&lt;/h4&gt;

&lt;p&gt;如上描述，二进制兼容问题是出现在相关类库对外暴露的API端，如果一些API的修改与原有版本产生了冲突，就会对基于老版本编译的客户端产生很大的影响。&lt;/p&gt;

&lt;p&gt;这里容易出现二进制兼容问题的修改如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;删除了API包名。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将API包中一个public类型改成了非public类型。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改了API中的public类型发生了改变，例如Class变成了Interface，或者Interface变成了Class。 &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对需要客户端实现的接口进行了修改。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改了API类型的参数顺序。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把一个非abstract类修改成为了abstract类。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;降低方法的可见性例如把protected修改为了private，或者把public修改为protected。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改了成员的属性，例如把非final 成员变成了final， 或者是非static的成员变成了static。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，上面的修改都是针对会被调用客户端对外可见的API来说的， 如果是内部包可见或者是私有方法或者成员的修改是不引起二进制兼容问题的。&lt;/p&gt;

&lt;p&gt;如果大家想详细了解API演进和二进制兼容的的问题可以参考[1]。&lt;/p&gt;

&lt;h4&gt;参考资料&lt;/h4&gt;

&lt;p&gt;[1]&lt;a href=&quot;http://wiki.eclipse.org/Evolving_Java-based_APIs_2&quot;&gt;&amp;quot;Evolving Java-based APIs 2: Achieving API Binary Compatibility&amp;quot;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Nov 2016 23:56:42 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2016/java-binary-compatibility/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2016/java-binary-compatibility/</guid>
        
        <category>Java</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>为什么开源社区使用邮件列表讨论问题</title>
        <description>&lt;p&gt;在Apache社区有一个不成文的规矩：“没有在邮件列表里面发生的事情就没有发生”。今天这篇blog就和大家聊聊为什么会有这样的规矩。&lt;/p&gt;

&lt;p&gt;由于社区的成员遍布世界各地，时差是大家在沟通的过程中需要解决的一个很重要的问题。在Apache社区大部分的开发人员都居住在欧美地区，如果要大家一起坐下来开会，基本选的时间都是在东半球的开发人员睡觉的时候。例如每年两次的Apache成员大会基本上就选在了北京时间凌晨三点左右召开。 通过邮件列表这样的方式可以比较好的解决时区问题，因为邮件是异步的，接收者可以选择他比较方便的时间回复信息。&lt;/p&gt;

&lt;p&gt;当然使用邮件列表还有一个好处就是，邮件存档检索都比较方便，这样可以让关心邮件主题的朋友随时跳进来参与讨论。 我经常可以看到在Camel的用户组里有人会就几个月以前讨论的问题接着发信寻找更好的解决方案。社区成员可以通过搜索公开的存档邮件及时获取到相关的问题的讨论上下文，通过邮件列表可以极大降低社区成员获取信息的成本，这对于人员流动性比较大的开源社区来说是非常重要的。&lt;/p&gt;

&lt;p&gt;说了这么多使用邮件列表沟通的好处，那为什么国人很少用邮件列表问问题呢？简单分析一下，可能会涉及几方面的问题。&lt;/p&gt;

&lt;p&gt;第一是语言问题，因为在Apache社区，大家都是用英语来进行沟通， 对于大多数的开发人员来说，他们想比较快的解决问题，往往会先选择使用Baidu搜索相关的中文解决方案，而很少尝试去邮件列表里面去用英文来问问题。对于大部分和用户使用相关的问题，使用中文来检索应该能找到相关的解决方案。但是如果我们想深入研讨软件内部的细节问题的时候，使用英文往往能获取到第一手的信息。&lt;/p&gt;

&lt;p&gt;第二可能是大家觉得邮件会比较慢， 如果邮件的讨论方正好分布在东西两个半球，一次有效的来回讨论可能就会占据一天的时间。也许正因为这种慢可以让我们在写邮件的时候可以好好考虑一下上下文的逻辑关系，以及相关讨论人的认知以及感受等问题，让大家的讨论能够比较通畅的进行下去。&lt;/p&gt;

&lt;p&gt;现在国内的开源社区发展地也非常迅猛，大家大多会选择QQ群或者微信群等这样的及时通讯群来进行交流。这样的交流的好处是大家可以随时随地进行沟通，由于大家在这样及时通讯工具里的沟通没有相关的存档检索功能，大家的讨论很难沉淀成为能被后续加入的成员所使用的有效信息。这样表面的繁荣很难有持续发展的动力。&lt;/p&gt;

&lt;p&gt;最近在Apache孵化项目社区中就有这样有关项目建立中文QQ群的讨论，有兴趣的同学可以通过&lt;a href=&quot;https://www.mail-archive.com/general@incubator.apache.org/msg57192.html&quot;&gt;邮件列表存档&lt;/a&gt;获取相关的内容。 当然由于这个主题涉及到多方面的内容，大家讨论的方向会比较多： 有讨论Apache是不是应该鼓励多语言讨论的，有讨论是不是邮件列表讨论是必须的。 就从方便让大家围观，及时全面了解问题的上下文的角度来说，大家应该能够体会到邮件列表的强大威力了。&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Nov 2016 00:32:54 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2016/why-we-use-mailing-list/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2016/why-we-use-mailing-list/</guid>
        
        <category>Open</category>
        
        <category>Source</category>
        
        
        <category>Open</category>
        
        <category>Source</category>
        
      </item>
    
      <item>
        <title>如何研读开源项目代码</title>
        <description>&lt;p&gt;今天在微博上看到庄表伟在知呼上回答的&lt;a href=&quot;http://www.zhihu.com/question/19637879&quot;&gt;如何更有效地学习开源项目的代码&lt;/a&gt;？&lt;/p&gt;

&lt;p&gt;我很认同他总结的 “学习开源，就尽可能在代码里找答案，而不是在代码之外找答案，那些都是二手的，而且很可能是不准确的。”  但是如何读好，读懂代码，我这边还是有不同的认识。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;1. 下载完整的工程文件&lt;/h3&gt;

&lt;p&gt;   &lt;/p&gt;

&lt;p&gt;需要从代码管理库下载完整的源代码，而不是简单的源代码文件包或者source.jar。这样做有很多好处，一个是你可以获取代码的修改记录，还有你可以获取到完整的测试代码，当你要提交patch的时候，你可以借助版本管理工具生成针对不同版本的patch。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;2. 示例代码与单元测试&lt;/h3&gt;

&lt;p&gt;    示例代码可以帮助你学会使用相关开源项目的API。很多朋友在使用开源项目的时候遇到一个小问题就发信给开发者要这样或者那样的示例代码，其实他们没有发现大部分的开源项目在开发的过程中，为了验证其实现的功能，都会写很多单元测试代码。这些代码其实非常好的示例代码。可能是下源码，建工程会花费你几个小时的时间，但是如果你想深入了解开源项目的话，这点投资还是很有价值的。&lt;/p&gt;

&lt;p&gt;     其实读单元测试的好处太多了，这里简单给大家列一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由于一个单元测试一般也就是几个小时的开发工作量，你很容易就能读懂相关的代码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个单元测试都是可以独立运行的，这样节省你跟踪调试的时间。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单元测试在很大程度定义了软件的功能，可以帮助你快速掌握项目的相关API。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你修改的开源项目的代码，你可以通过修改单元测试来验证你的修改是否正确。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;3.架构文档&lt;/h3&gt;

&lt;p&gt;     其实大部分的开源项目都会对其架构有一定的描述，这些描述可能会有点过时，但是通读一下会让你项目有一个比较深入的认识。这样做好比是让你对北京的二环，三环，四环，五环有个大体的认识。这样在你要对代码的某块内容进行详细研究的时候（例如找中关村的位置的时候，知道西北四环）就能很快定位了。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Dec 2011 07:36:20 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2011/reading-source-code/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2011/reading-source-code/</guid>
        
        <category>Open</category>
        
        <category>Source</category>
        
        
        <category>Open</category>
        
        <category>Source</category>
        
      </item>
    
      <item>
        <title>开源软件使用的几个阶段</title>
        <description>&lt;h1&gt;阶段一， 使用开源软件完成自己的日常工作。&lt;/h1&gt;

&lt;p&gt;虽然开源软件与其他商业软件相比较没有花哨的用户界面，没有完善的用户使用文档，但是这些开源软件可以满足大家日常工作的绝大部分要求。最重要的是这些开源软件对于最终用户来说都是可以无条件免费使用。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;这一阶段的门槛很低。大家使用搜索引擎很容易就能找到介绍相关的软件使用的页面或者是日志。大家只要把相关的软件发行版本下载本地就能马上开始使用了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;对于直接面向终端用户使用开源软来说，这一阶段的用户数是最大的，他们是开源用户社区的基础。对于这一阶段的用户来说，软件的可用行，易用性是他们最关心的问题。这些用户经过一段时间的培养，或者当他们对开源软件有了更高程度定制需求的话，他们很容就进入了第二阶段。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1&gt;阶段二， 修改开源软件满足自己的需要。&lt;/h1&gt;

&lt;p&gt;开源软件的最大好处就是代码公开，用户在遵守相关开源软件许可的前提下，可以根据自己的需要修改代码。通过修改代码，用户可以获得对开源软件掌控权。这也是目前国内厂商以及高校科研机构所看重的，当然这也是培养软件研发的队伍的一个行之有效的手段。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;在最近召开的开源大会上，我见到很多这样的用户：他们可能因为需要解决企业计算领域的问题，需要将多个开源软件结合在一起搭建业务系统，并且需要针对其特定功能对这些开源软件进行修改来满足自己的需求；他们有可能是以为项目课题的需要， 对某个开源软件进行了比较深入的研究之后，将其定制，包装之后。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;对于这样的用户来说，开源软件就变成一个一个的砖块。用户只需要对这些砖块进行少量修补就可以搭建出满足自己的需求应用。听起来这视乎是一条阳关大道，但是当你深入下去的时候，你会发现前面的道路充满的荆棘。 &lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;首先是缺乏技术支持，虽然大多数的开源项目都有文档，以及用户邮件列表提供免费的支持，但这些与商业软件提供的用户手册以及技术支持来说还是相距太远。如果你的问题很棘手，或者是项目进度很紧张的情况下，这样的免费支持是很难满足你的要求。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;其次是要在漫漫代码中定位问题，寻找解决方案是一个比较漫长的过程，其时间成本是可想而知的，当然如果你有足够的时间和精力的话，这样的投入也是值得的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;最后就是版本管理的问题。如果你对开源软件代码进行修改，同时这些修改没有进入开源项目的主分支上，那么你就需要维护一个自己的版本。版本管理的成本随着你对开源软件使用和修改的程度一同增加，而且这样的成本在开始使用的时候 隐形的，随着时间的推移，成本会不断增大。这也是开源软件使用第三阶段试图解决的一个重要问题。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1&gt;阶段三， 参与开源软件开发，在分享的知识的同时收获成长和快乐。&lt;/h1&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;在开源社区里面有一句话，当你奉献的同时，你会收获更多。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;拿前面提到的第二阶段版本管理来说， 如果你能把你的修改提交到开源项目的主线上，那你的版本维护成本就趋向于零；如果你在本地维护修改版本的话，一旦主线上进行的了相关bug的修改，你都需要同步过来，否则你本地版本的维护和升级都要你自己来做。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;软件开发是一个螺旋上升的过程，这个过程需要开发者和用户直接不断反馈，磨合。很难想象某一个软件在1.0的时候就能把所有的功能都实现完。这也是众多软件开发者愿意参与到开源软件开发的一个重要原因。他们在扮演用户的同时也扮演着开发者的角色。如果他们不满意开源软件的某一项功能，他们会圈起袖子直接修改代码，并且将自己的修改反馈到社区，而不是锁在柜子里面让它烂掉。 这样的好处是今天修改的内容，可能一个小时，或者明天就有人会提供反馈，在不断的思维碰撞中，大家能想出更好的想法。 开源开发者虽然都分布在不同的地方，但是这样的共享协作开发机制，从分享代码的基础上最大限度的降低了开源软件开发知识沟通成本，通过审查代码，用户直接反馈等多种手段保证了软件研发和创新的效率。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;目前国内进入这一阶段的开源用户还很少，有大量的用户还只停留在第二阶段。也许他们比较羞涩没有打算将自己的成果分享出来， 也许他们还没有体会到把这些成果分享出来会收获更多的乐趣。但是我有理由相信他们很快会进入到第三阶段的，因为只要经过适当的引导，由第二阶段进入到第三阶段是一个很自然的过程。&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Oct 2011 06:27:36 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2011/open-source-usage-in-china-post/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2011/open-source-usage-in-china-post/</guid>
        
        <category>OpenSource</category>
        
        
        <category>OpenSource</category>
        
      </item>
    
      <item>
        <title>开源两事记</title>
        <description>&lt;p&gt;最近发生了很多事情，让我不得不思考一下我现在和接下来需要做的事情。&lt;/p&gt;

&lt;p&gt;在过去的2007年中，开源软件开发方面上的两件事情使我受益非浅。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个是 CXF 2.0 的发布，用户社区的壮大。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那是在2007年7月初的时候，在此之前我没有想到CXF的用户邮件组会一下子活跃很多，记得当时我做过一个小小的统计，基本上是平均一个小时就有一封用户的来信，询问有关CXF使用问题。一下子回复用户的来信就成为了我每天日常工作的一部分。在回答用户的问题的过程中，我渐渐感觉开源项目社区（Community）的重要性。&lt;/p&gt;

&lt;p&gt;一直以来我都认为好的软件不是工程师设计出来的，而是用户们使用出来的。作为Coder你会根据需求设计代码，但是如果你写的软件没有人用，那你将因为无法得到及时的反馈，而不可能进一部分改进你的代码，或者是修正你设计中的缺陷。&lt;/p&gt;

&lt;p&gt;有人说开源软件和商业软件比，因为缺乏测试和支持，其软件质量让我们不能将开源软件应用到生产系统中。对此，我还是要用上面我说的那句话来回答，软件是使用出来的，而不是设计出来的。&lt;/p&gt;

&lt;p&gt;大量用户们的使用，给你写出的软件注入了无限的活力。一些用户会不断测试你的刚写出的代码；一些用户会帮助你完善文档；一些用户会跟踪你的代码并为他所遇到的问题打上补丁。同时这一切将会在你刚提交的代码后的几天之内发生。&lt;/p&gt;

&lt;p&gt;试想一下，如果你现在在开发一个商业软件，你也许会在提交代码后的两个礼拜中，无法得到你所写代码的直接反馈。或许当你在即将忘记你所写代码的某个时候，突然接到了用户或者是测试人员报过来的一个Bug，这个时候你对你所写的软件质量是一个什么样的感受。&lt;/p&gt;

&lt;p&gt;这也是我为什么愿意投入很多精力来回复开源社区用户们提问以及参与社区建设的重要原因之一。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个是成为Camel的Committer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果说成为CXF Committer是占了Initial Committer的便宜（不需要走Apache的Committer惯用流程），那我成为Camel的Committer可谓是经历了进半年的考察期。 起初接触Camel是因为James想将CXF集成进Camel中，而我当时对CXF有一定了解同时也想多参与一些Apache的项目开发，我认为成为Committer只需要提交3个以上patch就可以了。&lt;/p&gt;

&lt;p&gt;按照DanKlup 在CXF中写的&lt;a href=&quot;http://cxf.apache.org/getting-involved.html&quot;&gt;Getting involved&lt;/a&gt; 中的提示，要想成为 Apache 项目的Committer，你熟悉ASF的工作方式，同时一个重要内容是你需要通过不断用提交patch的方式骚扰项目中的其他Committer，让他们厌烦帮你打patch，为你挣取足够的获取Committer权力的信用。&lt;/p&gt;

&lt;p&gt;由于当时我还投入了部分精力在CXF项目中，在半年中打的patch不到10个，估计没有突破James对Committer的要求，所有迟迟没有获得Camel的Committer权限。好在两个礼拜前我终于拿到Camel的 committer权限，也让我再次体验了一下成为 Apache committer的快乐。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Feb 2008 18:13:12 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2008/something-about-opensource/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2008/something-about-opensource/</guid>
        
        <category>Open</category>
        
        <category>Source</category>
        
        
        <category>Open</category>
        
        <category>Source</category>
        
      </item>
    
      <item>
        <title>Java的动态链接</title>
        <description>&lt;p&gt; JAVA和C/C++的区别有很多，你知道Java程序需要链接吗？Java 语言与C/C++ 在语法上很相似，但是由于它是伴随着互连网络成长起来的，为了迎合异构主机构架以及支持安全的软件分发，逐步发展成为一个语言平台。我们知道如果用C/C++写程序，从源代码到可执行程序需要经历编译，链接两个步骤。但是用Java语言写程序则不同，你只需要将你的源代码编译成字节码 就可以了，字节代码通过Java虚机来运行。要概括上面两种语言的这一不同之处，我们可以说Java是通过Java解释来执行的，C/C++是通过编译来 执行的。&lt;/p&gt;

&lt;p&gt;如果你用C/C++来写一个通讯程序完成Intel/Windows 到Sparcs/Solarise两台计算机之间的通讯功能，你需要经历痛苦编译和链接。也许你会使用标准C编译器，使用其提供的最基本的C语言API， 再加上若干的#if...#define 写出一个在上面两个计算机都可以编译链接成功的源程序，这意味着所有标准C语言API之上的工作都要由你一个人来完成。也许你会在标准的C语言API上使 用C++来封装一个精巧的类库，或者使用别人的类库来屏蔽底层OS API的不同，并在这样类库之上写出一个漂亮的源程序。可见使用C/C++要完成上面的工作可不容易，你除了要为你写的源文件和不同的编译器的语法规则做斗争，将我们的源程序编译成为中间件文件；同时还需要为 你所使用第三方的类库文件与链接程序做斗争如果你源程序和第三方库不是采用一个编译器编译出来的，哪你还得找到第三方类库的源代码，或者是换一个编译器来 编译你的源程序。基本上要经历好几轮的修改、编译、链接，才能让的源程序进入运行状态。&lt;/p&gt;

&lt;p&gt;如果你采用Java来写这个程序则轻松了很多。你可以使用JDK所提供的API，也可以使用第三方的Java类库。你的源程序可以很轻松的编译成为字节 码，这些只是一个一个的程序块，如果想让程序运行起来，需要Java虚机在运行时动态加载（RunTime Link）其所需要的资源，使之成为一个可以运行的程序。Java语言这样做的好处显而易见，首先源程序只需要编译一次，成为独立与具体机器指令的中间文 件，然后这些字节码就可以在任意的标准的Java虚机上运行。&lt;/p&gt;

&lt;p&gt;说了这些众所周知的C/C++与Java语言在编译运行的不同，对我们有什么启发呢？笔者先后做过C/C++和Java的开发，开始并没有领会其中的真 谛，直到前几个月深入接触到了class loader才真正体会到Java这一RunTime Link 的神奇魅力，可以让我们完成很多静态链接所无法完成的任务。&lt;/p&gt;

&lt;p&gt;如果我们拿到了一个C/C++编译完成的可执行程序,如果这个时候你想为这个可执行程序添加一些可以扩展的功能，如果你这时没有源代码，那你等待你的可能 是处理复杂的汇编指令，或者采用钩子函数去替换可执行程序调用的API。如果你拿到的是JAVA程序，你可以像修改C/C++可执行程序一样修改Java 的目标文件字节码的方式来实现，但是我们可以通过一种更优美的方式来修改或者扩这Java程序的运行时的特性。&lt;/p&gt;

&lt;p&gt;因为Java是解释执行的，其目标文件字节码是一个非常小的，并且是很容易理解的指令集合。Java虚机为了能够让这些短小的指令集合能够运行起来，这就 是我们前面提到的C/C++程序链接（Link）所做的事情（链接就是要把程序运行所需要API以及相关的资源文件，都重新进行组织生成可以单独运行的程 序）。由于Java程序是运行在Java虚机之上的，自然的Java程序在运行过程中所需要加载的类文件或其他的资源文件都需要Java虚机来负责加载， 并提供管理和调用。&lt;/p&gt;

&lt;p&gt;写过Java程序的朋友也许经常会遇到这样一个问题吧，就是Exception in thread &amp;quot;main&amp;quot; java.lang.NoClassDefFoundError:XXX，一般遇到这个问题的时候，基本上都是因为你的CLASSPATH没有设置正确， 设置正确的CLASSPATH，就可以解决这个问题，但是有多少人会去深究其中的奥秘呢？&lt;/p&gt;

&lt;p&gt;首先我们来究其原因，我们知道Java虚机在运行的过程中是通过class loader动态读取Class文件，并将加载后Class的字节码交付给Java虚机执行。这个很容易理解，Java虚机不可能预先知道任意一个 Java程序需要的Class文件，所以Java虚机需要通过某种手段来实现Class文件的正常读写，上面的Exception就是Java虚机在加载 Class文件出现的。&lt;/p&gt;

&lt;p&gt;知道这一原理之后，我们可以在不修改源程序的基础上扩展Java第三方程序库的功能，或者说我们可以随意改变某个Class文件的指令，加入我们期望的扩展功能。通过修改字节码我们就很容易实现一个特定的扩展功能，或者是暴露给我们一个原来只能内部调用的方法。自己修改字节码会比较困难，我们可以通过调用一些第三方的程序库（BCEL，ASM等）来实现对应字节码的修改，通过class loader实现将修改后的字节码提交给JVM，然后链接执行。&lt;/p&gt;

&lt;p&gt;See， It is simple and easy.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Nov 2006 06:41:32 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2006/java-link-post/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2006/java-link-post/</guid>
        
        <category>Java</category>
        
        
        <category>Java</category>
        
      </item>
    
  </channel>
</rss>
