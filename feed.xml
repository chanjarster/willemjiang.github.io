<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>blog of Willem Jiang</title>
    <description>blog of Willem Jiang</description>
    <link>http://willemjiang.github.io/</link>
    <atom:link href="http://willemjiang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 13 Nov 2016 10:22:30 +0800</pubDate>
    <lastBuildDate>Sun, 13 Nov 2016 10:22:30 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>如何研读开源项目代码</title>
        <description>&lt;p&gt;今天在微博上看到庄表伟在知呼上回答的&lt;a href=&quot;http://www.zhihu.com/question/19637879&quot;&gt;如何更有效地学习开源项目的代码&lt;/a&gt;？&lt;/p&gt;

&lt;p&gt;我很认同他总结的 “学习开源，就尽可能在代码里找答案，而不是在代码之外找答案，那些都是二手的，而且很可能是不准确的。”  但是如何读好，读懂代码，我这边还是有不同的认识。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 下载完整的工程文件&lt;/h3&gt;

&lt;p&gt;   &lt;/p&gt;

&lt;p&gt;需要从代码管理库下载完整的源代码，而不是简单的源代码文件包或者source.jar。这样做有很多好处，一个是你可以获取代码的修改记录，还有你可以获取到完整的测试代码，当你要提交patch的时候，你可以借助版本管理工具生成针对不同版本的patch。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 示例代码与单元测试&lt;/h3&gt;

&lt;p&gt;    示例代码可以帮助你学会使用相关开源项目的API。很多朋友在使用开源项目的时候遇到一个小问题就发信给开发者要这样或者那样的示例代码，其实他们没有发现大部分的开源项目在开发的过程中，为了验证其实现的功能，都会写很多单元测试代码。这些代码其实非常好的示例代码。可能是下源码，建工程会花费你几个小时的时间，但是如果你想深入了解开源项目的话，这点投资还是很有价值的。&lt;/p&gt;

&lt;p&gt;     其实读单元测试的好处太多了，这里简单给大家列一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;由于一个单元测试一般也就是几个小时的开发工作量，你很容易就能读懂相关的代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个单元测试都是可以独立运行的，这样节省你跟踪调试的时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单元测试在很大程度定义了软件的功能，可以帮助你快速掌握项目的相关API。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你修改的开源项目的代码，你可以通过修改单元测试来验证你的修改是否正确。&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3.架构文档&lt;/h3&gt;

&lt;p&gt;     其实大部分的开源项目都会对其架构有一定的描述，这些描述可能会有点过时，但是通读一下会让你项目有一个比较深入的认识。这样做好比是让你对北京的二环，三环，四环，五环有个大体的认识。这样在你要对代码的某块内容进行详细研究的时候（例如找中关村的位置的时候，知道西北四环）就能很快定位了。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Dec 2011 07:36:20 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2011/reading-source-code/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2011/reading-source-code/</guid>
        
        <category>Open</category>
        
        <category>Source</category>
        
        
        <category>Open</category>
        
        <category>Source</category>
        
      </item>
    
      <item>
        <title>开源软件使用的几个阶段</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;阶段一， 使用开源软件完成自己的日常工作。&lt;/h1&gt;

&lt;p&gt;虽然开源软件与其他商业软件相比较没有花哨的用户界面，没有完善的用户使用文档，但是这些开源软件可以满足大家日常工作的绝大部分要求。最重要的是这些开源软件对于最终用户来说都是可以无条件免费使用。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;这一阶段的门槛很低。大家使用搜索引擎很容易就能找到介绍相关的软件使用的页面或者是日志。大家只要把相关的软件发行版本下载本地就能马上开始使用了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;对于直接面向终端用户使用开源软来说，这一阶段的用户数是最大的，他们是开源用户社区的基础。对于这一阶段的用户来说，软件的可用行，易用性是他们最关心的问题。这些用户经过一段时间的培养，或者当他们对开源软件有了更高程度定制需求的话，他们很容就进入了第二阶段。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;阶段二， 修改开源软件满足自己的需要。&lt;/h1&gt;

&lt;p&gt;开源软件的最大好处就是代码公开，用户在遵守相关开源软件许可的前提下，可以根据自己的需要修改代码。通过修改代码，用户可以获得对开源软件掌控权。这也是目前国内厂商以及高校科研机构所看重的，当然这也是培养软件研发的队伍的一个行之有效的手段。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;在最近召开的开源大会上，我见到很多这样的用户：他们可能因为需要解决企业计算领域的问题，需要将多个开源软件结合在一起搭建业务系统，并且需要针对其特定功能对这些开源软件进行修改来满足自己的需求；他们有可能是以为项目课题的需要， 对某个开源软件进行了比较深入的研究之后，将其定制，包装之后。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;对于这样的用户来说，开源软件就变成一个一个的砖块。用户只需要对这些砖块进行少量修补就可以搭建出满足自己的需求应用。听起来这视乎是一条阳关大道，但是当你深入下去的时候，你会发现前面的道路充满的荆棘。 &lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;首先是缺乏技术支持，虽然大多数的开源项目都有文档，以及用户邮件列表提供免费的支持，但这些与商业软件提供的用户手册以及技术支持来说还是相距太远。如果你的问题很棘手，或者是项目进度很紧张的情况下，这样的免费支持是很难满足你的要求。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;其次是要在漫漫代码中定位问题，寻找解决方案是一个比较漫长的过程，其时间成本是可想而知的，当然如果你有足够的时间和精力的话，这样的投入也是值得的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;最后就是版本管理的问题。如果你对开源软件代码进行修改，同时这些修改没有进入开源项目的主分支上，那么你就需要维护一个自己的版本。版本管理的成本随着你对开源软件使用和修改的程度一同增加，而且这样的成本在开始使用的时候 隐形的，随着时间的推移，成本会不断增大。这也是开源软件使用第三阶段试图解决的一个重要问题。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;阶段三， 参与开源软件开发，在分享的知识的同时收获成长和快乐。&lt;/h1&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;在开源社区里面有一句话，当你奉献的同时，你会收获更多。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;拿前面提到的第二阶段版本管理来说， 如果你能把你的修改提交到开源项目的主线上，那你的版本维护成本就趋向于零；如果你在本地维护修改版本的话，一旦主线上进行的了相关bug的修改，你都需要同步过来，否则你本地版本的维护和升级都要你自己来做。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;软件开发是一个螺旋上升的过程，这个过程需要开发者和用户直接不断反馈，磨合。很难想象某一个软件在1.0的时候就能把所有的功能都实现完。这也是众多软件开发者愿意参与到开源软件开发的一个重要原因。他们在扮演用户的同时也扮演着开发者的角色。如果他们不满意开源软件的某一项功能，他们会圈起袖子直接修改代码，并且将自己的修改反馈到社区，而不是锁在柜子里面让它烂掉。 这样的好处是今天修改的内容，可能一个小时，或者明天就有人会提供反馈，在不断的思维碰撞中，大家能想出更好的想法。 开源开发者虽然都分布在不同的地方，但是这样的共享协作开发机制，从分享代码的基础上最大限度的降低了开源软件开发知识沟通成本，通过审查代码，用户直接反馈等多种手段保证了软件研发和创新的效率。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;目前国内进入这一阶段的开源用户还很少，有大量的用户还只停留在第二阶段。也许他们比较羞涩没有打算将自己的成果分享出来， 也许他们还没有体会到把这些成果分享出来会收获更多的乐趣。但是我有理由相信他们很快会进入到第三阶段的，因为只要经过适当的引导，由第二阶段进入到第三阶段是一个很自然的过程。&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Oct 2011 06:27:36 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2011/open-source-usage-in-china-post/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2011/open-source-usage-in-china-post/</guid>
        
        <category>OpenSource</category>
        
        
        <category>OpenSource</category>
        
      </item>
    
      <item>
        <title>开源两事记</title>
        <description>&lt;p&gt;最近发生了很多事情，让我不得不思考一下我现在和接下来需要做的事情。&lt;/p&gt;

&lt;p&gt;在过去的2007年中，开源软件开发方面上的两件事情使我受益非浅。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个是 CXF 2.0 的发布，用户社区的壮大。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那是在2007年7月初的时候，在此之前我没有想到CXF的用户邮件组会一下子活跃很多，记得当时我做过一个小小的统计，基本上是平均一个小时就有一封用户的来信，询问有关CXF使用问题。一下子回复用户的来信就成为了我每天日常工作的一部分。在回答用户的问题的过程中，我渐渐感觉开源项目社区（Community）的重要性。&lt;/p&gt;

&lt;p&gt;一直以来我都认为好的软件不是工程师设计出来的，而是用户们使用出来的。作为Coder你会根据需求设计代码，但是如果你写的软件没有人用，那你将因为无法得到及时的反馈，而不可能进一部分改进你的代码，或者是修正你设计中的缺陷。&lt;/p&gt;

&lt;p&gt;有人说开源软件和商业软件比，因为缺乏测试和支持，其软件质量让我们不能将开源软件应用到生产系统中。对此，我还是要用上面我说的那句话来回答，软件是使用出来的，而不是设计出来的。&lt;/p&gt;

&lt;p&gt;大量用户们的使用，给你写出的软件注入了无限的活力。一些用户会不断测试你的刚写出的代码；一些用户会帮助你完善文档；一些用户会跟踪你的代码并为他所遇到的问题打上补丁。同时这一切将会在你刚提交的代码后的几天之内发生。&lt;/p&gt;

&lt;p&gt;试想一下，如果你现在在开发一个商业软件，你也许会在提交代码后的两个礼拜中，无法得到你所写代码的直接反馈。或许当你在即将忘记你所写代码的某个时候，突然接到了用户或者是测试人员报过来的一个Bug，这个时候你对你所写的软件质量是一个什么样的感受。&lt;/p&gt;

&lt;p&gt;这也是我为什么愿意投入很多精力来回复开源社区用户们提问以及参与社区建设的重要原因之一。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个是成为Camel的Committer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果说成为CXF Committer是占了Initial Committer的便宜（不需要走Apache的Committer惯用流程），那我成为Camel的Committer可谓是经历了进半年的考察期。 起初接触Camel是因为James想将CXF集成进Camel中，而我当时对CXF有一定了解同时也想多参与一些Apache的项目开发，我认为成为Committer只需要提交3个以上patch就可以了。&lt;/p&gt;

&lt;p&gt;按照DanKlup 在CXF中写的&lt;a href=&quot;http://cxf.apache.org/getting-involved.html&quot;&gt;Getting involved&lt;/a&gt; 中的提示，要想成为 Apache 项目的Committer，你熟悉ASF的工作方式，同时一个重要内容是你需要通过不断用提交patch的方式骚扰项目中的其他Committer，让他们厌烦帮你打patch，为你挣取足够的获取Committer权力的信用。&lt;/p&gt;

&lt;p&gt;由于当时我还投入了部分精力在CXF项目中，在半年中打的patch不到10个，估计没有突破James对Committer的要求，所有迟迟没有获得Camel的Committer权限。好在两个礼拜前我终于拿到Camel的 committer权限，也让我再次体验了一下成为 Apache committer的快乐。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Feb 2008 18:13:12 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2008/something-about-opensource/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2008/something-about-opensource/</guid>
        
        <category>Open</category>
        
        <category>Source</category>
        
        
        <category>Open</category>
        
        <category>Source</category>
        
      </item>
    
      <item>
        <title>Java的动态链接</title>
        <description>&lt;p&gt; JAVA和C/C++的区别有很多，你知道Java程序需要链接吗？Java 语言与C/C++ 在语法上很相似，但是由于它是伴随着互连网络成长起来的，为了迎合异构主机构架以及支持安全的软件分发，逐步发展成为一个语言平台。我们知道如果用C/C++写程序，从源代码到可执行程序需要经历编译，链接两个步骤。但是用Java语言写程序则不同，你只需要将你的源代码编译成字节码 就可以了，字节代码通过Java虚机来运行。要概括上面两种语言的这一不同之处，我们可以说Java是通过Java解释来执行的，C/C++是通过编译来 执行的。&lt;/p&gt;

&lt;p&gt;如果你用C/C++来写一个通讯程序完成Intel/Windows 到Sparcs/Solarise两台计算机之间的通讯功能，你需要经历痛苦编译和链接。也许你会使用标准C编译器，使用其提供的最基本的C语言API， 再加上若干的#if…#define 写出一个在上面两个计算机都可以编译链接成功的源程序，这意味着所有标准C语言API之上的工作都要由你一个人来完成。也许你会在标准的C语言API上使 用C++来封装一个精巧的类库，或者使用别人的类库来屏蔽底层OS API的不同，并在这样类库之上写出一个漂亮的源程序。可见使用C/C++要完成上面的工作可不容易，你除了要为你写的源文件和不同的编译器的语法规则做斗争，将我们的源程序编译成为中间件文件；同时还需要为 你所使用第三方的类库文件与链接程序做斗争如果你源程序和第三方库不是采用一个编译器编译出来的，哪你还得找到第三方类库的源代码，或者是换一个编译器来 编译你的源程序。基本上要经历好几轮的修改、编译、链接，才能让的源程序进入运行状态。&lt;/p&gt;

&lt;p&gt;如果你采用Java来写这个程序则轻松了很多。你可以使用JDK所提供的API，也可以使用第三方的Java类库。你的源程序可以很轻松的编译成为字节 码，这些只是一个一个的程序块，如果想让程序运行起来，需要Java虚机在运行时动态加载（RunTime Link）其所需要的资源，使之成为一个可以运行的程序。Java语言这样做的好处显而易见，首先源程序只需要编译一次，成为独立与具体机器指令的中间文 件，然后这些字节码就可以在任意的标准的Java虚机上运行。&lt;/p&gt;

&lt;p&gt;说了这些众所周知的C/C++与Java语言在编译运行的不同，对我们有什么启发呢？笔者先后做过C/C++和Java的开发，开始并没有领会其中的真 谛，直到前几个月深入接触到了class loader才真正体会到Java这一RunTime Link 的神奇魅力，可以让我们完成很多静态链接所无法完成的任务。&lt;/p&gt;

&lt;p&gt;如果我们拿到了一个C/C++编译完成的可执行程序,如果这个时候你想为这个可执行程序添加一些可以扩展的功能，如果你这时没有源代码，那你等待你的可能 是处理复杂的汇编指令，或者采用钩子函数去替换可执行程序调用的API。如果你拿到的是JAVA程序，你可以像修改C/C++可执行程序一样修改Java 的目标文件字节码的方式来实现，但是我们可以通过一种更优美的方式来修改或者扩这Java程序的运行时的特性。&lt;/p&gt;

&lt;p&gt;因为Java是解释执行的，其目标文件字节码是一个非常小的，并且是很容易理解的指令集合。Java虚机为了能够让这些短小的指令集合能够运行起来，这就 是我们前面提到的C/C++程序链接（Link）所做的事情（链接就是要把程序运行所需要API以及相关的资源文件，都重新进行组织生成可以单独运行的程 序）。由于Java程序是运行在Java虚机之上的，自然的Java程序在运行过程中所需要加载的类文件或其他的资源文件都需要Java虚机来负责加载， 并提供管理和调用。&lt;/p&gt;

&lt;p&gt;写过Java程序的朋友也许经常会遇到这样一个问题吧，就是Exception in thread “main” java.lang.NoClassDefFoundError:XXX，一般遇到这个问题的时候，基本上都是因为你的CLASSPATH没有设置正确， 设置正确的CLASSPATH，就可以解决这个问题，但是有多少人会去深究其中的奥秘呢？&lt;/p&gt;

&lt;p&gt;首先我们来究其原因，我们知道Java虚机在运行的过程中是通过class loader动态读取Class文件，并将加载后Class的字节码交付给Java虚机执行。这个很容易理解，Java虚机不可能预先知道任意一个 Java程序需要的Class文件，所以Java虚机需要通过某种手段来实现Class文件的正常读写，上面的Exception就是Java虚机在加载 Class文件出现的。&lt;/p&gt;

&lt;p&gt;知道这一原理之后，我们可以在不修改源程序的基础上扩展Java第三方程序库的功能，或者说我们可以随意改变某个Class文件的指令，加入我们期望的扩展功能。通过修改字节码我们就很容易实现一个特定的扩展功能，或者是暴露给我们一个原来只能内部调用的方法。自己修改字节码会比较困难，我们可以通过调用一些第三方的程序库（BCEL，ASM等）来实现对应字节码的修改，通过class loader实现将修改后的字节码提交给JVM，然后链接执行。&lt;/p&gt;

&lt;p&gt;See， It is simple and easy.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Nov 2006 06:41:32 +0800</pubDate>
        <link>http://willemjiang.github.io/blog/2006/java-link-post/</link>
        <guid isPermaLink="true">http://willemjiang.github.io/blog/2006/java-link-post/</guid>
        
        <category>Java</category>
        
        
        <category>Java</category>
        
      </item>
    
  </channel>
</rss>
